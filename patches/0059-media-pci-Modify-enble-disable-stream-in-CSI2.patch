From 9da221ff3a32069ba04dd0df4785ce8a0a4002bb Mon Sep 17 00:00:00 2001
From: Hongju Wang <hongju.wang@intel.com>
Date: Fri, 16 Jan 2026 00:47:04 -0700
Subject: [PATCH 59/76] media: pci: Modify enble/disable stream in CSI2

Signed-off-by: Hongju Wang <hongju.wang@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 .../media/pci/intel/ipu6/ipu6-isys-csi2.c     | 105 ++++++++++++------
 .../media/pci/intel/ipu6/ipu6-isys-csi2.h     |   7 +-
 .../media/pci/intel/ipu6/ipu6-isys-video.c    |  78 +++++++------
 3 files changed, 118 insertions(+), 72 deletions(-)

diff --git a/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c b/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
index d1fece6..1e4e70b 100644
--- a/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
+++ b/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
@@ -339,6 +339,12 @@ static int ipu6_isys_csi2_set_stream(struct v4l2_subdev *sd,
 	return ret;
 }
 
+/*
+ * Maximum stream ID is 63 for now, as we use u64 bitmask to represent a set
+ * of streams.
+ */
+#define CSI2_SUBDEV_MAX_STREAM_ID 63
+
 static int ipu6_isys_csi2_enable_streams(struct v4l2_subdev *sd,
 					 struct v4l2_subdev_state *state,
 					 u32 pad, u64 streams_mask)
@@ -346,54 +352,81 @@ static int ipu6_isys_csi2_enable_streams(struct v4l2_subdev *sd,
 	struct ipu6_isys_subdev *asd = to_ipu6_isys_subdev(sd);
 	struct ipu6_isys_csi2 *csi2 = to_ipu6_isys_csi2(asd);
 	struct ipu6_isys_csi2_timing timing = { };
-	struct v4l2_subdev *remote_sd;
-	struct media_pad *remote_pad;
-	u64 sink_streams;
-	int ret;
-
-	remote_pad = media_pad_remote_pad_first(&sd->entity.pads[CSI2_PAD_SINK]);
-	remote_sd = media_entity_to_v4l2_subdev(remote_pad->entity);
+	u32 sink_pad, sink_stream;
+	struct v4l2_subdev *r_sd;
+	struct media_pad *r_pad;
+	int ret, i;
+
+	if (!csi2->stream_count) {
+		ret = ipu6_isys_csi2_calc_timing(csi2, &timing, CSI2_ACCINV);
+		if (ret)
+			return ret;
+
+		ret = ipu6_isys_csi2_set_stream(sd, &timing, csi2->nlanes,
+						true);
+		if (ret)
+			return ret;
+	}
 
-	sink_streams =
-		v4l2_subdev_state_xlate_streams(state, pad, CSI2_PAD_SINK,
-						&streams_mask);
+	for (i = 0; i <= CSI2_SUBDEV_MAX_STREAM_ID; i++) {
+		if (streams_mask & BIT_ULL(i))
+			break;
+	}
 
-	ret = ipu6_isys_csi2_calc_timing(csi2, &timing, CSI2_ACCINV);
+	ret = v4l2_subdev_routing_find_opposite_end(&state->routing, pad, i,
+						    &sink_pad, &sink_stream);
 	if (ret)
 		return ret;
 
-	ret = ipu6_isys_csi2_set_stream(sd, &timing, csi2->nlanes, true);
-	if (ret)
-		return ret;
+	r_pad = media_pad_remote_pad_first(&sd->entity.pads[CSI2_PAD_SINK]);
+	r_sd = media_entity_to_v4l2_subdev(r_pad->entity);
 
-	ret = v4l2_subdev_enable_streams(remote_sd, remote_pad->index,
-					 sink_streams);
-	if (ret) {
-		ipu6_isys_csi2_set_stream(sd, NULL, 0, false);
-		return ret;
+	ret = v4l2_subdev_enable_streams(r_sd, r_pad->index,
+					 BIT_ULL(sink_stream));
+	if (!ret) {
+		csi2->stream_count++;
+		return 0;
 	}
 
-	return 0;
+	if (!csi2->stream_count)
+		ipu6_isys_csi2_set_stream(sd, NULL, 0, false);
+
+	return ret;
 }
 
 static int ipu6_isys_csi2_disable_streams(struct v4l2_subdev *sd,
 					  struct v4l2_subdev_state *state,
 					  u32 pad, u64 streams_mask)
 {
-	struct v4l2_subdev *remote_sd;
-	struct media_pad *remote_pad;
-	u64 sink_streams;
+	struct ipu6_isys_subdev *asd = to_ipu6_isys_subdev(sd);
+	struct ipu6_isys_csi2 *csi2 = to_ipu6_isys_csi2(asd);
+	u32 sink_pad, sink_stream;
+	struct v4l2_subdev *r_sd;
+	struct media_pad *r_pad;
+	int ret, i;
 
-	sink_streams =
-		v4l2_subdev_state_xlate_streams(state, pad, CSI2_PAD_SINK,
-						&streams_mask);
+	for (i = 0; i <= CSI2_SUBDEV_MAX_STREAM_ID; i++) {
+		if (streams_mask & BIT_ULL(i))
+			break;
+	}
 
-	remote_pad = media_pad_remote_pad_first(&sd->entity.pads[CSI2_PAD_SINK]);
-	remote_sd = media_entity_to_v4l2_subdev(remote_pad->entity);
+	ret = v4l2_subdev_routing_find_opposite_end(&state->routing, pad, i,
+						    &sink_pad, &sink_stream);
+	if (ret)
+		return ret;
 
-	ipu6_isys_csi2_set_stream(sd, NULL, 0, false);
+	r_pad = media_pad_remote_pad_first(&sd->entity.pads[CSI2_PAD_SINK]);
+	r_sd = media_entity_to_v4l2_subdev(r_pad->entity);
 
-	v4l2_subdev_disable_streams(remote_sd, remote_pad->index, sink_streams);
+	v4l2_subdev_disable_streams(r_sd, r_pad->index, BIT_ULL(sink_stream));
+
+	if (--csi2->stream_count)
+		return 0;
+
+	dev_dbg(&csi2->isys->adev->auxdev.dev,
+		"stream off CSI2-%u with %u lanes\n", csi2->port, csi2->nlanes);
+
+	ipu6_isys_csi2_set_stream(sd, NULL, 0, false);
 
 	return 0;
 }
@@ -592,7 +625,8 @@ void ipu6_isys_csi2_eof_event_by_stream(struct ipu6_isys_stream *stream)
 int ipu6_isys_csi2_get_remote_desc(u32 source_stream,
 				   struct ipu6_isys_csi2 *csi2,
 				   struct media_entity *source_entity,
-				   struct v4l2_mbus_frame_desc_entry *entry)
+				   struct v4l2_mbus_frame_desc_entry *entry,
+				   int *nr_queues)
 {
 	struct v4l2_mbus_frame_desc_entry *desc_entry = NULL;
 	struct device *dev = &csi2->isys->adev->auxdev.dev;
@@ -639,5 +673,14 @@ int ipu6_isys_csi2_get_remote_desc(u32 source_stream,
 
 	*entry = *desc_entry;
 
+	for (i = 0; i < desc.num_entries; i++) {
+		if (desc_entry->bus.csi2.vc == desc.entry[i].bus.csi2.vc)
+			(*nr_queues)++;
+	}
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6_ISYS_RESET
+	csi2->is_multiple = true;
+	dev_dbg(dev, "set csi2->is_multiple is true.\n");
+#endif
 	return 0;
 }
diff --git a/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h b/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h
index ce8eed9..7d751e5 100644
--- a/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h
+++ b/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h
@@ -43,6 +43,10 @@ struct ipu6_isys_csi2 {
 	u32 receiver_errors;
 	unsigned int nlanes;
 	unsigned int port;
+	unsigned int stream_count;
+#ifdef CONFIG_VIDEO_INTEL_IPU6_ISYS_RESET
+	bool is_multiple;
+#endif
 };
 
 struct ipu6_isys_csi2_timing {
@@ -73,6 +77,7 @@ void ipu6_isys_csi2_error(struct ipu6_isys_csi2 *csi2);
 int ipu6_isys_csi2_get_remote_desc(u32 source_stream,
 				   struct ipu6_isys_csi2 *csi2,
 				   struct media_entity *source_entity,
-				   struct v4l2_mbus_frame_desc_entry *entry);
+				   struct v4l2_mbus_frame_desc_entry *entry,
+				   int *nr_queues);
 
 #endif /* IPU6_ISYS_CSI2_H */
diff --git a/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-video.c b/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-video.c
index 148c790..b8cbfe2 100644
--- a/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-video.c
+++ b/6.18.0/drivers/media/pci/intel/ipu6/ipu6-isys-video.c
@@ -1035,35 +1035,40 @@ ipu6_isys_query_stream_by_source(struct ipu6_isys *isys, int source, u8 vc)
 	return stream;
 }
 
-static u64 get_stream_mask_by_pipeline(struct ipu6_isys_video *__av)
+static u32 get_remote_pad_stream(struct media_pad *r_pad)
 {
-	struct media_pipeline *pipeline =
-		media_entity_pipeline(&__av->vdev.entity);
+	struct v4l2_subdev_state *state;
+	struct v4l2_subdev *sd;
+	u32 stream_id = 0;
 	unsigned int i;
-	u64 stream_mask = 0;
 
-	for (i = 0; i < NR_OF_CSI2_SRC_PADS; i++) {
-		struct ipu6_isys_video *av = &__av->csi2->av[i];
+	sd = media_entity_to_v4l2_subdev(r_pad->entity);
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+	if (!state)
+		return 0;
 
-		if (pipeline == media_entity_pipeline(&av->vdev.entity))
-			stream_mask |= BIT_ULL(av->source_stream);
+	for (i = 0; i < state->stream_configs.num_configs; i++) {
+		struct v4l2_subdev_stream_config *cfg =
+			&state->stream_configs.configs[i];
+		if (cfg->pad == r_pad->index) {
+			stream_id = cfg->stream;
+			break;
+		}
 	}
 
-	return stream_mask;
+	v4l2_subdev_unlock_state(state);
+
+	return stream_id;
 }
 
 int ipu6_isys_video_set_streaming(struct ipu6_isys_video *av, int state,
 				  struct ipu6_isys_buffer_list *bl)
 {
-	struct v4l2_subdev_krouting *routing;
 	struct ipu6_isys_stream *stream = av->stream;
-	struct v4l2_subdev_state *subdev_state;
 	struct device *dev = &av->isys->adev->auxdev.dev;
 	struct v4l2_subdev *sd;
 	struct media_pad *r_pad;
-	u32 sink_pad, sink_stream;
-	u64 r_stream;
-	u64 stream_mask = 0;
+	u32 r_stream = 0;
 	int ret = 0;
 
 	dev_dbg(dev, "set stream: %d\n", state);
@@ -1073,31 +1078,22 @@ int ipu6_isys_video_set_streaming(struct ipu6_isys_video *av, int state,
 
 	sd = &stream->asd->sd;
 	r_pad = media_pad_remote_pad_first(&av->pad);
-	r_stream = ipu6_isys_get_src_stream_by_src_pad(sd, r_pad->index);
-
-	subdev_state = v4l2_subdev_lock_and_get_active_state(sd);
-	routing = &subdev_state->routing;
-	ret = v4l2_subdev_routing_find_opposite_end(routing, r_pad->index,
-						    r_stream, &sink_pad,
-						    &sink_stream);
-	v4l2_subdev_unlock_state(subdev_state);
-	if (ret)
-		return ret;
-
-	stream_mask = get_stream_mask_by_pipeline(av);
+	r_stream = get_remote_pad_stream(r_pad);
 	if (!state) {
 		stop_streaming_firmware(av);
 
 		/* stop sub-device which connects with video */
-		dev_dbg(dev, "stream off entity %s pad:%d mask:0x%llx\n",
-			sd->name, r_pad->index, stream_mask);
+		dev_dbg(dev, "disable streams %s pad:%d mask:0x%llx for %s\n",
+			sd->name, r_pad->index, BIT_ULL(r_stream),
+			stream->source_entity->name);
 		ret = v4l2_subdev_disable_streams(sd, r_pad->index,
-						  stream_mask);
+						  BIT_ULL(r_stream));
 		if (ret) {
-			dev_err(dev, "stream off %s failed with %d\n", sd->name,
-				ret);
+			dev_err(dev, "disable streams %s failed with %d\n",
+				sd->name, ret);
 			return ret;
 		}
+
 		close_streaming_firmware(av);
 	} else {
 		ret = start_stream_firmware(av, bl);
@@ -1107,12 +1103,14 @@ int ipu6_isys_video_set_streaming(struct ipu6_isys_video *av, int state,
 		}
 
 		/* start sub-device which connects with video */
-		dev_dbg(dev, "stream on %s pad %d mask 0x%llx\n", sd->name,
-			r_pad->index, stream_mask);
-		ret = v4l2_subdev_enable_streams(sd, r_pad->index, stream_mask);
+		dev_dbg(dev, "enable streams %s pad: %d mask:0x%llx for %s\n",
+			sd->name, r_pad->index, BIT_ULL(r_stream),
+			stream->source_entity->name);
+		ret = v4l2_subdev_enable_streams(sd, r_pad->index,
+						 BIT_ULL(r_stream));
 		if (ret) {
-			dev_err(dev, "stream on %s failed with %d\n", sd->name,
-				ret);
+			dev_err(dev, "enable streams %s failed with %d\n",
+				sd->name, ret);
 			goto out_media_entity_stop_streaming_firmware;
 		}
 	}
@@ -1276,8 +1274,6 @@ int ipu6_isys_setup_video(struct ipu6_isys_video *av,
 	/* Find the root */
 	state = v4l2_subdev_lock_and_get_active_state(remote_sd);
 	for_each_active_route(&state->routing, r) {
-		(*nr_queues)++;
-
 		if (r->source_pad == remote_pad->index)
 			route = r;
 	}
@@ -1292,11 +1288,13 @@ int ipu6_isys_setup_video(struct ipu6_isys_video *av,
 
 	ret = ipu6_isys_csi2_get_remote_desc(av->source_stream,
 					     to_ipu6_isys_csi2(asd),
-					     *source_entity, &entry);
+					     *source_entity, &entry,
+					      nr_queues);
 	if (ret == -ENOIOCTLCMD) {
 		av->vc = 0;
 		av->dt = ipu6_isys_mbus_code_to_mipi(pfmt->code);
-	} else if (!ret) {
+		*nr_queues = 1;
+	} else if (*nr_queues && !ret) {
 		dev_dbg(dev, "Framedesc: stream %u, len %u, vc %u, dt %#x\n",
 			entry.stream, entry.length, entry.bus.csi2.vc,
 			entry.bus.csi2.dt);
-- 
2.43.0

